<?php
/**
 * User: Zachary Tong
 * Date: 2013-02-21
 * Time: 10:22 PM
 * Auto-generated by "generate.tests.php"
 */

namespace Sherlock\tests;

use Sherlock\Sherlock;

class QueryTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var \Sherlock\sherlock
     */
    protected $object;


    public function __construct()
    {
        try {
            $sherlock = new Sherlock(
                array(
                    "hosts" => array(
                        "localhost:9200"
                    )
                )
            );
            //Create the index
            $index = $sherlock->index('testqueries');
            $response = $index->create();
        } catch (\Exception $e) {}
    }


    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        $this->object = new Sherlock(
            array(
                "hosts" => array(
                    "localhost:9200"
                )
            )
        );
    }


    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
        /*
        try {
            $this->object->index('testqueries')->delete();
        } catch (\Exception $e) {

        }
        */
    }


    public function assertThrowsException($exception_name, $code)
    {
        $e = null;
        try {
            $code();
        } catch (\Exception $e) {
            // No more code, we only want to catch the exception in $e
        }

        $this->assertInstanceOf($exception_name, $e);

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Bool::must
     * @covers sherlock\Sherlock\components\queries\Bool::must_not
     * @covers sherlock\Sherlock\components\queries\Bool::should
     * @covers sherlock\Sherlock\components\queries\Bool::minimum_number_should_match
     * @covers sherlock\Sherlock\components\queries\Bool::boost
     * @covers sherlock\Sherlock\components\queries\Bool::disable_coord
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testBool()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Bool()->must(
            array(
                Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"),
                Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")
            )
        )
            ->must_not(
                array(
                    Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"),
                    Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")
                )
            )
            ->should(
                array(
                    Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"),
                    Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")
                )
            )
            ->minimum_number_should_match(3)
            ->boost(0.5)
            ->disable_coord(3);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"bool":{"must":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary2":{"value":"auxillary2"}}}],"must_not":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary2":{"value":"auxillary2"}}}],"should":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary2":{"value":"auxillary2"}}}],"minimum_number_should_match":3,"boost":0.5,"disable_coord":3}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Bool::must
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testBoolSingleMust()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $bool = Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary");
        $query = Sherlock::queryBuilder()->Bool()->must($bool);
        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"bool":{"must":[{"term":{"auxillary":{"value":"auxillary"}}}],"must_not":[],"should":[]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Bool::should
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testBoolSingleShould()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $bool = Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary");
        $query = Sherlock::queryBuilder()->Bool()->should($bool);
        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"bool":{"must":[],"must_not":[],"should":[{"term":{"auxillary":{"value":"auxillary"}}}]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Bool::must_not
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testBoolSingleMustNot()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $bool = Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary");
        $query = Sherlock::queryBuilder()->Bool()->must_not($bool);
        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"bool":{"must":[],"must_not":[{"term":{"auxillary":{"value":"auxillary"}}}],"should":[]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Bool::must
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testBoolMultipleMustInline()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $bool = Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary");
        $query = Sherlock::queryBuilder()->Bool()->must($bool, $bool, $bool);
        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"bool":{"must":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary":{"value":"auxillary"}}}],"must_not":[],"should":[]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Bool::should
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testBoolMultipleShouldInline()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $bool = Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary");
        $query = Sherlock::queryBuilder()->Bool()->should($bool, $bool, $bool);
        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"bool":{"must":[],"must_not":[],"should":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary":{"value":"auxillary"}}}]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Bool::must_not
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testBoolMultipleMustNotInline()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $bool = Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary");
        $query = Sherlock::queryBuilder()->Bool()->must_not($bool, $bool, $bool);
        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"bool":{"must":[],"must_not":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary":{"value":"auxillary"}}}],"should":[]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Boosting::positive
     * @covers sherlock\Sherlock\components\queries\Boosting::negative
     * @covers sherlock\Sherlock\components\queries\Boosting::negative_boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testBoosting()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Boosting()->positive(
            Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary")
        )
            ->negative(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
            ->negative_boost(0.5);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"boosting":{"positive":{"term":{"auxillary":{"value":"auxillary"}}},"negative":{"term":{"auxillary":{"value":"auxillary"}}},"negative_boost":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\ConstantScore::filter
     * @covers sherlock\Sherlock\components\queries\ConstantScore::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testConstantScore()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->ConstantScore()->filter(
            Sherlock::filterBuilder()->Term()->field("auxillary")->term("auxillary")
        )
            ->boost(0.5);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"constant_score":{"filter":{"term":{"auxillary":"auxillary","_cache":true}},"boost":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\ConstantScore::filter
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testConstantScoreNoBoost()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->ConstantScore()->filter(
                     Sherlock::filterBuilder()->Term()->field("auxillary")->term("auxillary")
                 );


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"constant_score":{"filter":{"term":{"auxillary":"auxillary","_cache":true}}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\DisMax::tie_breaker
     * @covers sherlock\Sherlock\components\queries\DisMax::boost
     * @covers sherlock\Sherlock\components\queries\DisMax::queries
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testDisMax()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->DisMax()->tie_breaker(0.5)
            ->boost(0.5)
            ->queries(
                array(
                    Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"),
                    Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")
                )
            );


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"dis_max":{"tie_breaker":0.5,"boost":0.5,"queries":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary2":{"value":"auxillary2"}}}]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\DisMax::tie_breaker
     * @covers sherlock\Sherlock\components\queries\DisMax::boost
     * @covers sherlock\Sherlock\components\queries\DisMax::queries
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testDisMaxSingleQuery()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->DisMax()->tie_breaker(0.5)
                 ->boost(0.5)
                 ->queries(
                    Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary")
                );


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"dis_max":{"tie_breaker":0.5,"boost":0.5,"queries":[{"term":{"auxillary":{"value":"auxillary"}}}]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\DisMax::tie_breaker
     * @covers sherlock\Sherlock\components\queries\DisMax::boost
     * @covers sherlock\Sherlock\components\queries\DisMax::queries
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testDisMaxMultipleInlineQueries()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $term = Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary");
        $query = Sherlock::queryBuilder()->DisMax()->tie_breaker(0.5)
                 ->boost(0.5)
                 ->queries($term, $term, $term);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"dis_max":{"tie_breaker":0.5,"boost":0.5,"queries":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary":{"value":"auxillary"}}}]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\FilteredQuery::query
     * @covers sherlock\Sherlock\components\queries\FilteredQuery::filter
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testFilteredQuery()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->FilteredQuery()->query(
            Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary")
        )
            ->filter(Sherlock::filterBuilder()->Term()->field("auxillary")->term("auxillary"));


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"filtered":{"query":{"term":{"auxillary":{"value":"auxillary"}}},"filter":{"term":{"auxillary":"auxillary","_cache":true}}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Fuzzy::field
     * @covers sherlock\Sherlock\components\queries\Fuzzy::value
     * @covers sherlock\Sherlock\components\queries\Fuzzy::boost
     * @covers sherlock\Sherlock\components\queries\Fuzzy::min_similarity
     * @covers sherlock\Sherlock\components\queries\Fuzzy::prefix_length
     * @covers sherlock\Sherlock\components\queries\Fuzzy::max_expansions
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testFuzzy()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Fuzzy()->field("testString")
            ->value("testString")
            ->boost(0.5)
            ->min_similarity(0.5)
            ->prefix_length(3)
            ->max_expansions(3);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"fuzzy":{"testString":{"value":"testString","boost":0.5,"min_similarity":0.5,"prefix_length":3,"max_expansions":3}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::fields
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::like_text
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::max_query_terms
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::min_similarity
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::prefix_length
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::boost
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::analyzer
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::ignore_tf
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testFuzzyLikeThis()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->FuzzyLikeThis()->fields(
            array(
                Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"),
                Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")
            )
        )
            ->like_text("testString")
            ->max_query_terms(3)
            ->min_similarity(0.5)
            ->prefix_length(3)
            ->boost(0.5)
            ->analyzer("testString")
            ->ignore_tf("testString");


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"fuzzy_like_this":{"fields":[{},{}],"like_text":"testString","max_query_terms":3,"min_similarity":0.5,"prefix_length":3,"boost":0.5,"analyzer":"testString","ignore_tf":"testString"}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::field
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::like_text
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::max_query_terms
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::min_similarity
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::prefix_length
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::boost
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::analyzer
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::ignore_tf
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testFuzzyLikeThisField()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->FuzzyLikeThisField()->field("testString")
            ->like_text("testString")
            ->max_query_terms(3)
            ->min_similarity(0.5)
            ->prefix_length(3)
            ->boost(0.5)
            ->analyzer("testString")
            ->ignore_tf("testString");


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"fuzzy_like_this_field":{"testString":{"like_text":"testString","max_query_terms":3,"min_similarity":0.5,"prefix_length":3,"boost":0.5,"analyzer":"testString","ignore_tf":"testString"}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @todo build proper test for HasChild
     * @covers sherlock\Sherlock\components\queries\HasChild::type
     * @covers sherlock\Sherlock\components\queries\HasChild::score_type
     * @covers sherlock\Sherlock\components\queries\HasChild::query
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testHasChild()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->HasChild()->type("testString")
            ->score_type("none")
            ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"));


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"has_child":{"type":"testString","score_type":"none","query":{"term":{"auxillary":{"value":"auxillary"}}}}}}';
        $this->assertEquals($expectedData, $data);

        //$resp = $req->execute();

    }


    /**
     * @todo build proper test for HasParent
     * @covers sherlock\Sherlock\components\queries\HasParent::parent_type
     * @covers sherlock\Sherlock\components\queries\HasParent::score_type
     * @covers sherlock\Sherlock\components\queries\HasParent::query
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testHasParent()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->HasParent()->parent_type("testString")
            ->score_type("none")
            ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"));


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"has_parent":{"parent_type":"testString","score_type":"none","query":{"term":{"auxillary":{"value":"auxillary"}}}}}}';
        $this->assertEquals($expectedData, $data);

        //$resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Ids::type
     * @covers sherlock\Sherlock\components\queries\Ids::values
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testIds()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Ids()->type("testString")
            ->values(
                array(
                    Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"),
                    Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")
                )
            );


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"ids":{"type":"testString","values":[{},{}]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Indices::indices
     * @covers sherlock\Sherlock\components\queries\Indices::query
     * @covers sherlock\Sherlock\components\queries\Indices::no_match_query
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function  testIndices()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Indices()->indices('test', 'testqueries')
            ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
            ->no_match_query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"));


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"indices":{"indices":["test","testqueries"],"query":{"term":{"auxillary":{"value":"auxillary"}}},"no_match_query":{"term":{"auxillary":{"value":"auxillary"}}}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Match::field
     * @covers sherlock\Sherlock\components\queries\Match::query
     * @covers sherlock\Sherlock\components\queries\Match::boost
     * @covers sherlock\Sherlock\components\queries\Match::operator
     * @covers sherlock\Sherlock\components\queries\Match::analyzer
     * @covers sherlock\Sherlock\components\queries\Match::fuzziness
     * @covers sherlock\Sherlock\components\queries\Match::fuzzy_rewrite
     * @covers sherlock\Sherlock\components\queries\Match::lenient
     * @covers sherlock\Sherlock\components\queries\Match::max_expansions
     * @covers sherlock\Sherlock\components\queries\Match::minimum_should_match
     * @covers sherlock\Sherlock\components\queries\Match::prefix_length
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testMatch()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Match()->field("testString")
            ->query("testString")
            ->boost(0.5)
            ->operator("AND")
            ->analyzer("default")
            ->fuzziness(0.5)
            ->lenient(true)
            ->max_expansions(3)
            ->minimum_should_match(3)
            ->prefix_length(3)
            ->type("phrase");


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"match":{"testString":{"query":"testString","boost":0.5,"operator":"AND","analyzer":"default","fuzziness":0.5,"lenient":true,"max_expansions":3,"minimum_should_match":3,"prefix_length":3,"type":"phrase"}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\MatchAll::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testMatchAll()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->MatchAll()->boost(0.5);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"match_all":{"boost":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    public function testFromField()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test")->from(5);
        $query = Sherlock::queryBuilder()->MatchAll();


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"match_all":[]},"from":5}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    public function testSizeField()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test")->size(5);
        $query = Sherlock::queryBuilder()->MatchAll();


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"match_all":[]},"size":5}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    public function testSizeFromField()
    {

        $indexName = 'testqueries';
        $indexType = 'test';
        $from      = 2;
        $size      = 2;

        $request = $this->object->search();

        $query = Sherlock::queryBuilder()->MatchAll();
        $request->index($indexName)->type($indexType)->query($query);

        if ($from) {
            $request->index($indexName)->type($indexType)->from($from);
        }

        if ($size) {
            $request->index($indexName)->type($indexType)->size($size);
        }

        $data         = $request->toJSON();
        $expectedData = '{"query":{"match_all":[]},"from":2,"size":2}';
        $this->assertEquals($expectedData, $data);

    }


    /**
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::fields
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::like_text
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::min_term_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::max_query_terms
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::percent_terms_to_match
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::stop_words
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::min_doc_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::max_doc_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::min_word_len
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::max_word_len
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::boost_terms
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testMoreLikeThis()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->MoreLikeThis()->fields(
            array(
                Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"),
                Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")
            )
        )
            ->like_text("testString")
            ->min_term_freq(3)
            ->max_query_terms(3)
            ->percent_terms_to_match(0.5)
            ->stop_words(
                array(
                    Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"),
                    Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")
                )
            )
            ->min_doc_freq(3)
            ->max_doc_freq(3)
            ->min_word_len(3)
            ->max_word_len(3)
            ->boost_terms(3)
            ->boost(0.5);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"more_like_this":{"fields":[{},{}],"like_text":"testString","min_term_freq":3,"max_query_terms":3,"percent_terms_to_match":0.5,"stop_words":[{},{}],"min_doc_freq":3,"max_doc_freq":3,"min_word_len":3,"max_word_len":3,"boost_terms":3,"boost":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::field
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::like_text
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::min_term_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::max_query_terms
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::percent_terms_to_match
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::stop_words
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::min_doc_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::max_doc_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::min_word_len
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::max_word_len
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::boost_terms
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testMoreLikeThisField()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->MoreLikeThisField()->field("testField")
            ->like_text("testString")
            ->min_term_freq(3)
            ->max_query_terms(3)
            ->percent_terms_to_match(0.5)
            ->stop_words(array("test", "test2"))
            ->min_doc_freq(3)
            ->max_doc_freq(3)
            ->min_word_len(3)
            ->max_word_len(3)
            ->boost_terms(3)
            ->boost(0.5);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"more_like_this_field":{"testField":{"like_text":"testString","min_term_freq":3,"max_query_terms":3,"percent_terms_to_match":0.5,"stop_words":["test","test2"],"min_doc_freq":3,"max_doc_freq":3,"min_word_len":3,"max_word_len":3,"boost_terms":3,"boost":0.5}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @todo Build valid test for Nested objects
     * @covers sherlock\Sherlock\components\queries\Nested::path
     * @covers sherlock\Sherlock\components\queries\Nested::score_mode
     * @covers sherlock\Sherlock\components\queries\Nested::query
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testNested()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Nested()->path("testString")
            ->score_mode("avg")
            ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"));


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"nested":{"path":"testString","score_mode":"avg","query":{"term":{"auxillary":{"value":"auxillary"}}}}}}';
        $this->assertEquals($expectedData, $data);

        //$resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Prefix::field
     * @covers sherlock\Sherlock\components\queries\Prefix::value
     * @covers sherlock\Sherlock\components\queries\Prefix::boost
     * @covers sherlock\Sherlock\components\queries\Prefix::analyzer
     * @covers sherlock\Sherlock\components\queries\Prefix::slop
     * @covers sherlock\Sherlock\components\queries\Prefix::max_expansions
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testPrefix()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Prefix()->field("testString")
            ->value("testString")
            ->boost(0.5)
            ->analyzer("testString")
            ->slop(3)
            ->max_expansions(3);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"prefix":{"testString":{"value":"testString","boost":0.5,"analyzer":"testString","slop":3,"max_expansions":3}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\QueryString::query
     * @covers sherlock\Sherlock\components\queries\QueryString::default_field
     * @covers sherlock\Sherlock\components\queries\QueryString::boost
     * @covers sherlock\Sherlock\components\queries\QueryString::enable_position_increments
     * @covers sherlock\Sherlock\components\queries\QueryString::default_operator
     * @covers sherlock\Sherlock\components\queries\QueryString::analyzer
     * @covers sherlock\Sherlock\components\queries\QueryString::allow_leading_wildcard
     * @covers sherlock\Sherlock\components\queries\QueryString::lowercase_expanded_terms
     * @covers sherlock\Sherlock\components\queries\QueryString::fuzzy_min_sim
     * @covers sherlock\Sherlock\components\queries\QueryString::fuzzy_prefix_length
     * @covers sherlock\Sherlock\components\queries\QueryString::lenient
     * @covers sherlock\Sherlock\components\queries\QueryString::phrase_slop
     * @covers sherlock\Sherlock\components\queries\QueryString::analyze_wildcard
     * @covers sherlock\Sherlock\components\queries\QueryString::auto_generate_phrase_queries
     * @covers sherlock\Sherlock\components\queries\QueryString::rewrite
     * @covers sherlock\Sherlock\components\queries\QueryString::quote_analyzer
     * @covers sherlock\Sherlock\components\queries\QueryString::quote_field_suffix
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testQueryString()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->QueryString()->query("testString")
            ->default_field("_all")
            ->boost(0.5)
            ->enable_position_increments(3)
            ->default_operator("OR")
            ->analyzer("default")
            ->allow_leading_wildcard(3)
            ->lowercase_expanded_terms(3)
            ->fuzzy_min_sim(0.5)
            ->fuzzy_prefix_length(3)
            ->lenient(true)
            ->phrase_slop(3)
            ->analyze_wildcard(true)
            ->auto_generate_phrase_queries(3)
            ->rewrite("constant_score_default")
            ->quote_analyzer("standard")
            ->quote_field_suffix(".unstemmed");


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"query_string":{"query":"testString","default_field":"_all","boost":0.5,"enable_position_increments":3,"default_operator":"OR","analyzer":"default","allow_leading_wildcard":3,"lowercase_expanded_terms":3,"fuzzy_min_sim":0.5,"fuzzy_prefix_length":3,"lenient":true,"phrase_slop":3,"analyze_wildcard":true,"auto_generate_phrase_queries":3,"quote_analyzer":"standard","quote_field_suffix":".unstemmed"},"rewrite":"constant_score_default"}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::query
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::fields
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::boost
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::enable_position_increments
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::default_operator
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::analyzer
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::allow_leading_wildcard
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::lowercase_expanded_terms
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::fuzzy_min_sim
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::fuzzy_prefix_length
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::lenient
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::phrase_slop
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::analyze_wildcard
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::auto_generate_phrase_queries
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::rewrite
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::quote_analyzer
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::quote_field_suffix
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::use_dis_max
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::tie_breaker
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testQueryStringMultiField()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->QueryStringMultiField()->query("testString")
            ->fields(
                array(
                    Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"),
                    Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")
                )
            )
            ->boost(0.5)
            ->enable_position_increments(true)
            ->default_operator("AND")
            ->analyzer("default")
            ->allow_leading_wildcard(true)
            ->lowercase_expanded_terms(3)
            ->fuzzy_min_sim(0.5)
            ->fuzzy_prefix_length(3)
            ->lenient(3)
            ->phrase_slop(3)
            ->analyze_wildcard(true)
            ->auto_generate_phrase_queries(true)
            ->rewrite("constant_score_default")
            ->quote_analyzer("standard")
            ->quote_field_suffix(".unstemmed")
            ->use_dis_max(true)
            ->tie_breaker(3);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"query_string":{"query":"testString","fields":[{},{}],"boost":0.5,"enable_position_increments":true,"default_operator":"AND","analyzer":"default","allow_leading_wildcard":true,"lowercase_expanded_terms":3,"fuzzy_min_sim":0.5,"fuzzy_prefix_length":3,"lenient":3,"phrase_slop":3,"analyze_wildcard":true,"auto_generate_phrase_queries":true,"quote_analyzer":"standard","quote_field_suffix":".unstemmed","use_dis_max":true,"tie_breaker":3},"rewrite":"constant_score_default"}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Range::field
     * @covers sherlock\Sherlock\components\queries\Range::from
     * @covers sherlock\Sherlock\components\queries\Range::to
     * @covers sherlock\Sherlock\components\queries\Range::include_lower
     * @covers sherlock\Sherlock\components\queries\Range::include_upper
     * @covers sherlock\Sherlock\components\queries\Range::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testRange()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Range()->field("testString")
            ->from("testString")
            ->to("testString")
            ->include_lower(true)
            ->include_upper(true)
            ->boost(0.5);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"range":{"testString":{"from":"testString","to":"testString","include_lower":true,"include_upper":true,"boost":0.5}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Term::field
     * @covers sherlock\Sherlock\components\queries\Term::term
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testTerm()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Term()->field("testString")
            ->term("testString");


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"term":{"testString":{"value":"testString"}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Terms::field
     * @covers sherlock\Sherlock\components\queries\Terms::term
     * @covers sherlock\Sherlock\components\queries\Terms::minimum_match
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testTerms()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Terms()->field("testString")
            ->terms('term', 'term2')
            ->minimum_match(3);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"terms":{"testString":["term","term2"],"minimum_match":3}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Terms()->field("testString")
            ->terms(array('term', 'term2'))
            ->minimum_match(3);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"terms":{"testString":["term","term2"],"minimum_match":3}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @todo construct proper test for TopChildren
     * @covers sherlock\Sherlock\components\queries\TopChildren::type
     * @covers sherlock\Sherlock\components\queries\TopChildren::query
     * @covers sherlock\Sherlock\components\queries\TopChildren::score
     * @covers sherlock\Sherlock\components\queries\TopChildren::factor
     * @covers sherlock\Sherlock\components\queries\TopChildren::incremental_factor
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testTopChildren()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->TopChildren()->type("testString")
            ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
            ->score("max")
            ->factor(3)
            ->incremental_factor(3);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"top_children":{"type":"testString","query":{"term":{"auxillary":{"value":"auxillary"}}},"score":"max","factor":3,"incremental_factor":3}}}';
        $this->assertEquals($expectedData, $data);

        //$resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\queries\Wildcard::field
     * @covers sherlock\Sherlock\components\queries\Wildcard::value
     * @covers sherlock\Sherlock\components\queries\Wildcard::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testWildcard()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Wildcard()->field("testString")
            ->value("testString")
            ->boost(0.5);


        $req->query($query);

        $data         = $req->toJSON();
        $expectedData = '{"query":{"wildcard":{"testString":{"value":"testString","boost":0.5}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }


    /**
     * @covers sherlock\Sherlock\components\sorts\Field::name
     * @covers sherlock\Sherlock\components\queries\Field::sort_order
     * @covers sherlock\Sherlock\components\queries\Field::missing
     * @covers sherlock\Sherlock\components\queries\Field::ignore_unmapped
     * @covers sherlock\Sherlock::sortBuilder
     */
    public function testSort()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->MatchAll()->boost(0.5);
        $req->query($query);

        $sort = Sherlock::sortBuilder();

        $sortValues[] = $sort->Field()->name("sort1")->order('asc');
        $sortValues[] = $sort->Field()->name("sort2")->order('desc');
        $sortValues[] = $sort->Field()->name("_score");
        $sortValues[] = $sort->Field()->name("sort3")->missing("_last");
        $sortValues[] = $sort->Field()->name("sort3")->ignore_unmapped(true);

        $req->sort($sortValues);

        $data = $req->toJSON();

        $expectedData = '{"query":{"match_all":{"boost":0.5}},"sort":[{"sort1":{"sort_mode":null,"order":"asc","missing":null,"ignore_unmapped":null}},{"sort2":{"sort_mode":null,"order":"desc","missing":null,"ignore_unmapped":null}},{"_score":{"sort_mode":null,"order":null,"missing":null,"ignore_unmapped":null}},{"sort3":{"sort_mode":null,"order":null,"missing":"_last","ignore_unmapped":null}},{"sort3":{"sort_mode":null,"order":null,"missing":null,"ignore_unmapped":true}}]}';
        $this->assertEquals($expectedData, $data);

    }


//    public function testRawRequest()
//    {
//        $req = $this->object->raw();
//        $req->uri("testindex/_search")->method("post")->body('{"query":{"match_all":{"boost":0.5}}}');
//
//        $data         = $req->toJSON();
//        $expectedData = '{"query":{"match_all":{"boost":0.5}}}';
//        $this->assertEquals($expectedData, $data);
//
//        $resp = $req->execute();
//
//        print_r($resp);
//
//    }
//
//
//    public function testRawQueryBuilding()
//    {
//
//        $req = $this->object->search();
//        $req->index("test3")->type("benchmark");
//
//        $expectedData = array("query" => array("term" => array("field1" => array("value" => "town"))));
//
//        $req->query(Sherlock::queryBuilder()->Raw($expectedData['query']));
//        $data = $req->toJSON();
//
//        $expectedData = json_encode($expectedData);
//        $this->assertEquals($expectedData, $data);
//
//    }


}
