<?php
/**
 * User: Zachary Tong
 * Date: 2013-02-21
 * Time: 10:22 PM
 * Auto-generated by "generate.tests.php"
 */

namespace Sherlock\tests;
use Analog\Analog;
use Sherlock\Sherlock;

class QueryTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var \Sherlock\sherlock
     */
    protected $object;

    public function __construct()
    {
        /*
        try {
            $sherlock = new \Sherlock\sherlock;
            $sherlock->addNode('localhost', '9200');
            //Create the index
            $index = $sherlock->index('testqueries');
            $response = $index->create();
        } catch (\Exception $e) {}
        */
    }

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        $this->object = new Sherlock();
        $this->object->addNode('localhost', '9200');
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
        /*
        try {
            $this->object->index('testqueries')->delete();
        } catch (\Exception $e) {

        }
        */
    }

    public function assertThrowsException($exception_name, $code)
    {
        $e = null;
        try {
            $code();
        } catch (\Exception $e) {
            // No more code, we only want to catch the exception in $e
        }

        $this->assertInstanceOf($exception_name, $e);

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Bool::must
     * @covers sherlock\Sherlock\components\queries\Bool::must_not
     * @covers sherlock\Sherlock\components\queries\Bool::should
     * @covers sherlock\Sherlock\components\queries\Bool::minimum_number_should_match
     * @covers sherlock\Sherlock\components\queries\Bool::boost
     * @covers sherlock\Sherlock\components\queries\Bool::disable_coord
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
    public function testBool()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Bool()->must(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ->must_not(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ->should(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ->minimum_number_should_match(3)
                ->boost(0.5)
                ->disable_coord(3)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"bool":{"must":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary2":{"value":"auxillary2"}}}],"must_not":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary2":{"value":"auxillary2"}}}],"should":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary2":{"value":"auxillary2"}}}],"minimum_number_should_match":3,"boost":0.5,"disable_coord":3}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Boosting::positive
     * @covers sherlock\Sherlock\components\queries\Boosting::negative
     * @covers sherlock\Sherlock\components\queries\Boosting::negative_boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testBoosting()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Boosting()->positive(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->negative(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->negative_boost(0.5)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"boosting":{"positive":{"term":{"auxillary":{"value":"auxillary"}}},"negative":{"term":{"auxillary":{"value":"auxillary"}}},"negative_boost":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\ConstantScore::filter
     * @covers sherlock\Sherlock\components\queries\ConstantScore::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testConstantScore()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->ConstantScore()->filter(Sherlock::filterBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->boost(0.5)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"constant_score":{"filter":{"term":{"auxillary":"auxillary","_cache":true}},"boost":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\CustomBoostFactor::query
     * @covers sherlock\Sherlock\components\queries\CustomBoostFactor::boost_factor
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testCustomBoostFactor()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->CustomBoostFactor()->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->boost_factor(0.5)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"custom_boost_factor":{"query":{"term":{"auxillary":{"value":"auxillary"}}},"boost_factor":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\CustomFiltersScore::query
     * @covers sherlock\Sherlock\components\queries\CustomFiltersScore::filters
     * @covers sherlock\Sherlock\components\queries\CustomFiltersScore::score_mode
     * @covers sherlock\Sherlock\components\queries\CustomFiltersScore::max_boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testCustomFiltersScore()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->CustomFiltersScore()->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->filters(Sherlock::filterBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->score_mode("first")
                ->max_boost(0.5)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"custom_filters_score":{"query":{"term":{"auxillary":{"value":"auxillary"}}},"filters":[{"filter":{"term":{"auxillary":"auxillary","_cache":true}}}],"score_mode":"first","max_boost":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\CustomScore::query
     * @covers sherlock\Sherlock\components\queries\CustomScore::params
     * @covers sherlock\Sherlock\components\queries\CustomScore::script
     * @covers sherlock\Sherlock\components\queries\CustomScore::lang
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testCustomScore()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->CustomScore()->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->params(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ->script("_score")
                ->lang("mvel")
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"custom_score":{"query":{"term":{"auxillary":{"value":"auxillary"}}},"params":[{},{}],"script":"_score","lang":"mvel"}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\DisMax::tie_breaker
     * @covers sherlock\Sherlock\components\queries\DisMax::boost
     * @covers sherlock\Sherlock\components\queries\DisMax::queries
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testDisMax()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->DisMax()->tie_breaker(0.5)
                ->boost(0.5)
                ->queries(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"dis_max":{"tie_breaker":0.5,"boost":0.5,"queries":[{"term":{"auxillary":{"value":"auxillary"}}},{"term":{"auxillary2":{"value":"auxillary2"}}}]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Field::field
     * @covers sherlock\Sherlock\components\queries\Field::query
     * @covers sherlock\Sherlock\components\queries\Field::boost
     * @covers sherlock\Sherlock\components\queries\Field::enable_position_increments
     * @covers sherlock\Sherlock\components\queries\Field::default_operator
     * @covers sherlock\Sherlock\components\queries\Field::analyzer
     * @covers sherlock\Sherlock\components\queries\Field::allow_leading_wildcard
     * @covers sherlock\Sherlock\components\queries\Field::lowercase_expanded_terms
     * @covers sherlock\Sherlock\components\queries\Field::fuzzy_min_sim
     * @covers sherlock\Sherlock\components\queries\Field::fuzzy_prefix_length
     * @covers sherlock\Sherlock\components\queries\Field::lenient
     * @covers sherlock\Sherlock\components\queries\Field::phrase_slop
     * @covers sherlock\Sherlock\components\queries\Field::analyze_wildcard
     * @covers sherlock\Sherlock\components\queries\Field::auto_generate_phrase_queries
     * @covers sherlock\Sherlock\components\queries\Field::rewrite
     * @covers sherlock\Sherlock\components\queries\Field::quote_analyzer
     * @covers sherlock\Sherlock\components\queries\Field::quote_field_suffix
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testField()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Field()->field("testString")
                ->query("testString")
                ->boost(0.5)
                ->enable_position_increments(3)
                ->default_operator("AND")
                ->analyzer("default")
                ->allow_leading_wildcard(true)
                ->lowercase_expanded_terms(3)
                ->fuzzy_min_sim(0.5)
                ->fuzzy_prefix_length(3)
                ->phrase_slop(3)
                ->analyze_wildcard(true)
                ->auto_generate_phrase_queries(3)
                ->rewrite("constant_score_default")
                ->quote_analyzer("standard")
                ->quote_field_suffix(".unstemmed")
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"field":{"testString":{"query":"testString","boost":0.5,"enable_position_increments":3,"default_operator":"AND","analyzer":"default","allow_leading_wildcard":true,"lowercase_expanded_terms":3,"fuzzy_min_sim":0.5,"fuzzy_prefix_length":3,"phrase_slop":3,"analyze_wildcard":true,"auto_generate_phrase_queries":3,"quote_analyzer":"standard","quote_field_suffix":".unstemmed"},"rewrite":"constant_score_default"}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\FilteredQuery::query
     * @covers sherlock\Sherlock\components\queries\FilteredQuery::filter
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testFilteredQuery()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->FilteredQuery()->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->filter(Sherlock::filterBuilder()->Term()->field("auxillary")->term("auxillary"))
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"filtered":{"query":{"term":{"auxillary":{"value":"auxillary"}}},"filter":{}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Fuzzy::field
     * @covers sherlock\Sherlock\components\queries\Fuzzy::value
     * @covers sherlock\Sherlock\components\queries\Fuzzy::boost
     * @covers sherlock\Sherlock\components\queries\Fuzzy::min_similarity
     * @covers sherlock\Sherlock\components\queries\Fuzzy::prefix_length
     * @covers sherlock\Sherlock\components\queries\Fuzzy::max_expansions
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testFuzzy()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Fuzzy()->field("testString")
                ->value("testString")
                ->boost(0.5)
                ->min_similarity(0.5)
                ->prefix_length(3)
                ->max_expansions(3)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"fuzzy":{"testString":{"value":"testString","boost":0.5,"min_similarity":0.5,"prefix_length":3,"max_expansions":3}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::fields
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::like_text
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::max_query_terms
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::min_similarity
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::prefix_length
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::boost
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::analyzer
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThis::ignore_tf
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testFuzzyLikeThis()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->FuzzyLikeThis()->fields(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ->like_text("testString")
                ->max_query_terms(3)
                ->min_similarity(0.5)
                ->prefix_length(3)
                ->boost(0.5)
                ->analyzer("testString")
                ->ignore_tf("testString")
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"fuzzy_like_this":{"fields":[{},{}],"like_text":"testString","max_query_terms":3,"min_similarity":0.5,"prefix_length":3,"boost":0.5,"analyzer":"testString","ignore_tf":"testString"}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::field
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::like_text
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::max_query_terms
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::min_similarity
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::prefix_length
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::boost
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::analyzer
     * @covers sherlock\Sherlock\components\queries\FuzzyLikeThisField::ignore_tf
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testFuzzyLikeThisField()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->FuzzyLikeThisField()->field("testString")
                ->like_text("testString")
                ->max_query_terms(3)
                ->min_similarity(0.5)
                ->prefix_length(3)
                ->boost(0.5)
                ->analyzer("testString")
                ->ignore_tf("testString")
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"fuzzy_like_this_field":{"testString":{"like_text":"testString","max_query_terms":3,"min_similarity":0.5,"prefix_length":3,"boost":0.5,"analyzer":"testString","ignore_tf":"testString"}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @todo build proper test for HasChild
     * @covers sherlock\Sherlock\components\queries\HasChild::type
     * @covers sherlock\Sherlock\components\queries\HasChild::score_type
     * @covers sherlock\Sherlock\components\queries\HasChild::query
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testHasChild()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->HasChild()->type("testString")
                ->score_type("none")
                ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"has_child":{"type":"testString","score_type":"none","query":{"term":{"auxillary":{"value":"auxillary"}}}}}}';
        $this->assertEquals($expectedData, $data);

        //$resp = $req->execute();

    }

    /**
     * @todo build proper test for HasParent
     * @covers sherlock\Sherlock\components\queries\HasParent::parent_type
     * @covers sherlock\Sherlock\components\queries\HasParent::score_type
     * @covers sherlock\Sherlock\components\queries\HasParent::query
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testHasParent()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->HasParent()->parent_type("testString")
                ->score_type("none")
                ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"has_parent":{"parent_type":"testString","score_type":"none","query":{"term":{"auxillary":{"value":"auxillary"}}}}}}';
        $this->assertEquals($expectedData, $data);

        //$resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Ids::type
     * @covers sherlock\Sherlock\components\queries\Ids::values
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testIds()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Ids()->type("testString")
                ->values(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"ids":{"type":"testString","values":[{},{}]}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Indices::indices
     * @covers sherlock\Sherlock\components\queries\Indices::query
     * @covers sherlock\Sherlock\components\queries\Indices::no_match_query
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function  testIndices()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Indices()->indices('test','testqueries')
                ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->no_match_query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"indices":{"indices":["test","testqueries"],"query":{"term":{"auxillary":{"value":"auxillary"}}},"no_match_query":{"term":{"auxillary":{"value":"auxillary"}}}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Match::field
     * @covers sherlock\Sherlock\components\queries\Match::query
     * @covers sherlock\Sherlock\components\queries\Match::boost
     * @covers sherlock\Sherlock\components\queries\Match::operator
     * @covers sherlock\Sherlock\components\queries\Match::analyzer
     * @covers sherlock\Sherlock\components\queries\Match::fuzziness
     * @covers sherlock\Sherlock\components\queries\Match::fuzzy_rewrite
     * @covers sherlock\Sherlock\components\queries\Match::lenient
     * @covers sherlock\Sherlock\components\queries\Match::max_expansions
     * @covers sherlock\Sherlock\components\queries\Match::minimum_should_match
     * @covers sherlock\Sherlock\components\queries\Match::prefix_length
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testMatch()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Match()->field("testString")
                ->query("testString")
                ->boost(0.5)
                ->operator("AND")
                ->analyzer("default")
                ->fuzziness(0.5)
                ->lenient(true)
                ->max_expansions(3)
                ->minimum_should_match(3)
                ->prefix_length(3)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"match":{"testString":{"query":"testString","boost":0.5,"operator":"AND","analyzer":"default","fuzziness":0.5,"lenient":true,"max_expansions":3,"minimum_should_match":3,"prefix_length":3,"type":null}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\MatchAll::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testMatchAll()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->MatchAll()->boost(0.5)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"match_all":{"boost":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::fields
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::like_text
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::min_term_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::max_query_terms
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::percent_terms_to_match
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::stop_words
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::min_doc_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::max_doc_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::min_word_len
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::max_word_len
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::boost_terms
     * @covers sherlock\Sherlock\components\queries\MoreLikeThis::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testMoreLikeThis()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->MoreLikeThis()->fields(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ->like_text("testString")
                ->min_term_freq(3)
                ->max_query_terms(3)
                ->percent_terms_to_match(0.5)
                ->stop_words(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ->min_doc_freq(3)
                ->max_doc_freq(3)
                ->min_word_len(3)
                ->max_word_len(3)
                ->boost_terms(3)
                ->boost(0.5)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"more_like_this":{"fields":[{},{}],"like_text":"testString","min_term_freq":3,"max_query_terms":3,"percent_terms_to_match":0.5,"stop_words":[{},{}],"min_doc_freq":3,"max_doc_freq":3,"min_word_len":3,"max_word_len":3,"boost_terms":3,"boost":0.5}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::field
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::like_text
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::min_term_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::max_query_terms
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::percent_terms_to_match
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::stop_words
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::min_doc_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::max_doc_freq
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::min_word_len
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::max_word_len
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::boost_terms
     * @covers sherlock\Sherlock\components\queries\MoreLikeThisField::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testMoreLikeThisField()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->MoreLikeThisField()->field("testField")
                ->like_text("testString")
                ->min_term_freq(3)
                ->max_query_terms(3)
                ->percent_terms_to_match(0.5)
                ->stop_words(array("test", "test2"))
                ->min_doc_freq(3)
                ->max_doc_freq(3)
                ->min_word_len(3)
                ->max_word_len(3)
                ->boost_terms(3)
                ->boost(0.5)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"more_like_this_field":{"testField":{"like_text":"testString","min_term_freq":3,"max_query_terms":3,"percent_terms_to_match":0.5,"stop_words":["test","test2"],"min_doc_freq":3,"max_doc_freq":3,"min_word_len":3,"max_word_len":3,"boost_terms":3,"boost":0.5}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @todo Build valid test for Nested objects
     * @covers sherlock\Sherlock\components\queries\Nested::path
     * @covers sherlock\Sherlock\components\queries\Nested::score_mode
     * @covers sherlock\Sherlock\components\queries\Nested::query
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testNested()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Nested()->path("testString")
                ->score_mode("avg")
                ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"nested":{"path":"testString","score_mode":"avg","query":{"term":{"auxillary":{"value":"auxillary"}}}}}}';
        $this->assertEquals($expectedData, $data);

        //$resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Prefix::field
     * @covers sherlock\Sherlock\components\queries\Prefix::value
     * @covers sherlock\Sherlock\components\queries\Prefix::boost
     * @covers sherlock\Sherlock\components\queries\Prefix::analyzer
     * @covers sherlock\Sherlock\components\queries\Prefix::slop
     * @covers sherlock\Sherlock\components\queries\Prefix::max_expansions
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testPrefix()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Prefix()->field("testString")
                ->value("testString")
                ->boost(0.5)
                ->analyzer("testString")
                ->slop(3)
                ->max_expansions(3)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"prefix":{"testString":{"value":"testString","boost":0.5,"analyzer":"testString","slop":3,"max_expansions":3}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\QueryString::query
     * @covers sherlock\Sherlock\components\queries\QueryString::default_field
     * @covers sherlock\Sherlock\components\queries\QueryString::boost
     * @covers sherlock\Sherlock\components\queries\QueryString::enable_position_increments
     * @covers sherlock\Sherlock\components\queries\QueryString::default_operator
     * @covers sherlock\Sherlock\components\queries\QueryString::analyzer
     * @covers sherlock\Sherlock\components\queries\QueryString::allow_leading_wildcard
     * @covers sherlock\Sherlock\components\queries\QueryString::lowercase_expanded_terms
     * @covers sherlock\Sherlock\components\queries\QueryString::fuzzy_min_sim
     * @covers sherlock\Sherlock\components\queries\QueryString::fuzzy_prefix_length
     * @covers sherlock\Sherlock\components\queries\QueryString::lenient
     * @covers sherlock\Sherlock\components\queries\QueryString::phrase_slop
     * @covers sherlock\Sherlock\components\queries\QueryString::analyze_wildcard
     * @covers sherlock\Sherlock\components\queries\QueryString::auto_generate_phrase_queries
     * @covers sherlock\Sherlock\components\queries\QueryString::rewrite
     * @covers sherlock\Sherlock\components\queries\QueryString::quote_analyzer
     * @covers sherlock\Sherlock\components\queries\QueryString::quote_field_suffix
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testQueryString()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->QueryString()->query("testString")
                ->default_field("_all")
                ->boost(0.5)
                ->enable_position_increments(3)
                ->default_operator("OR")
                ->analyzer("default")
                ->allow_leading_wildcard(3)
                ->lowercase_expanded_terms(3)
                ->fuzzy_min_sim(0.5)
                ->fuzzy_prefix_length(3)
                ->lenient(true)
                ->phrase_slop(3)
                ->analyze_wildcard(true)
                ->auto_generate_phrase_queries(3)
                ->rewrite("constant_score_default")
                ->quote_analyzer("standard")
                ->quote_field_suffix(".unstemmed")
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"query_string":{"query":"testString","default_field":"_all","boost":0.5,"enable_position_increments":3,"default_operator":"OR","analyzer":"default","allow_leading_wildcard":3,"lowercase_expanded_terms":3,"fuzzy_min_sim":0.5,"fuzzy_prefix_length":3,"lenient":true,"phrase_slop":3,"analyze_wildcard":true,"auto_generate_phrase_queries":3,"quote_analyzer":"standard","quote_field_suffix":".unstemmed"},"rewrite":"constant_score_default"}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::query
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::fields
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::boost
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::enable_position_increments
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::default_operator
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::analyzer
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::allow_leading_wildcard
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::lowercase_expanded_terms
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::fuzzy_min_sim
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::fuzzy_prefix_length
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::lenient
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::phrase_slop
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::analyze_wildcard
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::auto_generate_phrase_queries
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::rewrite
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::quote_analyzer
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::quote_field_suffix
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::use_dis_max
     * @covers sherlock\Sherlock\components\queries\QueryStringMultiField::tie_breaker
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testQueryStringMultiField()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->QueryStringMultiField()->query("testString")
                ->fields(array(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"), Sherlock::queryBuilder()->Term()->field("auxillary2")->term("auxillary2")))
                ->boost(0.5)
                ->enable_position_increments(true)
                ->default_operator("AND")
                ->analyzer("default")
                ->allow_leading_wildcard(true)
                ->lowercase_expanded_terms(3)
                ->fuzzy_min_sim(0.5)
                ->fuzzy_prefix_length(3)
                ->lenient(3)
                ->phrase_slop(3)
                ->analyze_wildcard(true)
                ->auto_generate_phrase_queries(true)
                ->rewrite("constant_score_default")
                ->quote_analyzer("standard")
                ->quote_field_suffix(".unstemmed")
                ->use_dis_max(true)
                ->tie_breaker(3);

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"query_string":{"query":"testString","fields":[{},{}],"boost":0.5,"enable_position_increments":true,"default_operator":"AND","analyzer":"default","allow_leading_wildcard":true,"lowercase_expanded_terms":3,"fuzzy_min_sim":0.5,"fuzzy_prefix_length":3,"lenient":3,"phrase_slop":3,"analyze_wildcard":true,"auto_generate_phrase_queries":true,"quote_analyzer":"standard","quote_field_suffix":".unstemmed","use_dis_max":true,"tie_breaker":3},"rewrite":"constant_score_default"}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Range::field
     * @covers sherlock\Sherlock\components\queries\Range::from
     * @covers sherlock\Sherlock\components\queries\Range::to
     * @covers sherlock\Sherlock\components\queries\Range::include_lower
     * @covers sherlock\Sherlock\components\queries\Range::include_upper
     * @covers sherlock\Sherlock\components\queries\Range::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testRange()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Range()->field("testString")
                ->from("testString")
                ->to("testString")
                ->include_lower(true)
                ->include_upper(true)
                ->boost(0.5)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"range":{"testString":{"from":"testString","to":"testString","include_lower":true,"include_upper":true,"boost":0.5}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Term::field
     * @covers sherlock\Sherlock\components\queries\Term::term
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testTerm()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Term()->field("testString")
                ->term("testString")
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"term":{"testString":{"value":"testString"}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Terms::field
     * @covers sherlock\Sherlock\components\queries\Terms::term
     * @covers sherlock\Sherlock\components\queries\Terms::minimum_match
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testTerms()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Terms()->field("testString")
                ->terms('term', 'term2')
                ->minimum_match(3)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"terms":{"testString":["term","term2"],"minimum_match":3}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Terms()->field("testString")
            ->terms(array('term', 'term2'))
            ->minimum_match(3)
        ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"terms":{"testString":["term","term2"],"minimum_match":3}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @todo construct proper test for TopChildren
     * @covers sherlock\Sherlock\components\queries\TopChildren::type
     * @covers sherlock\Sherlock\components\queries\TopChildren::query
     * @covers sherlock\Sherlock\components\queries\TopChildren::score
     * @covers sherlock\Sherlock\components\queries\TopChildren::factor
     * @covers sherlock\Sherlock\components\queries\TopChildren::incremental_factor
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testTopChildren()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->TopChildren()->type("testString")
                ->query(Sherlock::queryBuilder()->Term()->field("auxillary")->term("auxillary"))
                ->score("max")
                ->factor(3)
                ->incremental_factor(3)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"top_children":{"type":"testString","query":{"term":{"auxillary":{"value":"auxillary"}}},"score":"max","factor":3,"incremental_factor":3}}}';
        $this->assertEquals($expectedData, $data);

        //$resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\queries\Wildcard::field
     * @covers sherlock\Sherlock\components\queries\Wildcard::value
     * @covers sherlock\Sherlock\components\queries\Wildcard::boost
     * @covers sherlock\Sherlock\requests\SearchRequest::query
     * @covers sherlock\Sherlock\requests\SearchRequest::toJSON
     */
        public function testWildcard()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->Wildcard()->field("testString")
                ->value("testString")
                ->boost(0.5)
                ;

        \Analog\Analog::log($query->toJSON(), \Analog\Analog::DEBUG);

        $req->query($query);

        $data = $req->toJSON();
        $expectedData = '{"query":{"wildcard":{"testString":{"value":"testString","boost":0.5}}}}';
        $this->assertEquals($expectedData, $data);

        $resp = $req->execute();

    }

    /**
     * @covers sherlock\Sherlock\components\sorts\Field::name
     * @covers sherlock\Sherlock\components\queries\Field::sort_order
     * @covers sherlock\Sherlock\components\queries\Field::missing
     * @covers sherlock\Sherlock\components\queries\Field::ignore_unmapped
     * @covers sherlock\Sherlock::sortBuilder
     */
    public function testSort()
    {
        $req = $this->object->search();
        $req->index("testqueries")->type("test");
        $query = Sherlock::queryBuilder()->MatchAll()->boost(0.5);
        $req->query($query);

        $sort = Sherlock::sortBuilder();

        $sortValues[] = $sort->Field()->name("sort1")->order('asc');
        $sortValues[] = $sort->Field()->name("sort2")->order('desc');
        $sortValues[] = $sort->Field()->name("_score");
        $sortValues[] = $sort->Field()->name("sort3")->missing("_last");
        $sortValues[] = $sort->Field()->name("sort3")->ignore_unmapped(true);

        $req->sort($sortValues);

        Analog::log($req->toJSON(), \Analog\Analog::DEBUG);

        $data = $req->toJSON();

        $expectedData = '{"query":{"match_all":{"boost":0.5}},"sort":[{"sort1":{"sort_mode":null,"order":"asc","missing":null,"ignore_unmapped":null}},{"sort2":{"sort_mode":null,"order":"desc","missing":null,"ignore_unmapped":null}},{"_score":{"sort_mode":null,"order":null,"missing":null,"ignore_unmapped":null}},{"sort3":{"sort_mode":null,"order":null,"missing":"_last","ignore_unmapped":null}},{"sort3":{"sort_mode":null,"order":null,"missing":null,"ignore_unmapped":true}}]}';
        $this->assertEquals($expectedData, $data);

    }

}
